
"""
Program to generate patterns in scales.
Goal:
    - input type of scale and root, starting note, and pattern description (ie up 2, down 1), and the program will
    generate all the segments of the pattern and display them in musescore

Todo:
- determine how to algorithmically spell notes enharmonically

Done:
- account for octave changes
"""
from numpy import sign

notes = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B']


class Scale:
    def __init__(self, root, tonality, user_scale_pattern=None):
        self.root = root.upper()
        self.notes = [self.root]
        self.tonality = tonality
        # Dict containing all patterns generated with these notes
        self.patterns = {}

        if user_scale_pattern:
            self.user_scale_pattern = user_scale_pattern
        else:
            self.user_scale_pattern = None

        self.generate_notes()

    def generate_notes(self):
        """
        Uses scale patterns in half steps to generate the notes for the scale, given the
        root and tonality.
        """
        if self.user_scale_pattern is not None:
            scale_pattern = self.user_scale_pattern
        elif self.tonality.lower() == 'minor pentatonic':
            scale_pattern = [3, 5, 7, 10]
        elif self.tonality.lower() == 'major pentatonic':
            scale_pattern = [2, 4, 7, 9]
        elif self.tonality.lower() == 'major':
            scale_pattern = [2, 4, 5, 7, 9, 11]
        elif self.tonality.lower() == 'minor':
            scale_pattern = [2, 3, 5, 7, 8, 10]
        elif self.tonality.lower() == 'augmented':
            scale_pattern = [3, 4, 7, 8, 11]
        elif self.tonality.lower() in ['hw diminished', 'half whole diminished']:
            scale_pattern = [1, 3, 4, 6, 7, 9, 10]
        elif self.tonality.lower() in ['wh diminished', 'whole half diminished']:
            scale_pattern = [2, 3, 5, 6, 8, 9, 11]
        elif self.tonality.lower() == 'chromatic':
            scale_pattern = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        else:
            print('Not one of the valid scale tonalities.')
            scale_pattern = []
        for num in scale_pattern:
            self.notes.append(notes[(notes.index(self.root) + num) % 12])

    def print_notes(self):
        print(*self.notes)

    def create_pattern(self, pattern_name, pattern_sequence, starting_note=None, curr_octave=4):
        """
        Creates the pattern using the pattern sequence, a list of integers giving the number and direction (sign)
        of steps to take after each note in the pattern.
        The pattern is composed of segments, where each segment is generated by one iteration of the pattern sequence.
        :param pattern_name: string with name of pattern
        :param pattern_sequence: a list of integers represent the steps taken in the scale to generate the pattern
        :param starting_note: first note of the pattern (must be one of the notes in the scale), defaults to root
        :param curr_octave: the starting octave (in scientific pitch notation), default=4
        """
        if starting_note is None:
            starting_note = self.root
        elif starting_note not in self.notes:
            return 'Invalid starting note.'
        pattern = []
        curr_index = self.notes.index(starting_note)
        while True:
            # Breaks out of the loop when the starting note is the first note in a segment again (after the first
            # segment), meaning the pattern has been fully generated
            if self.notes[curr_index] == starting_note and len(pattern) > 0:
                break
            curr_segment = []
            # Iteratively adds the current note to the current segment, finds the new index using the numbers in the
            # pattern sequence, and calculates the new octave
            curr_note = self.notes[curr_index]
            for num in pattern_sequence:
                curr_segment.append(curr_note + str(curr_octave))
                curr_index = (curr_index + num) % len(self.notes)
                next_note = self.notes[curr_index]
                curr_octave = self.generate_new_octave(curr_note, next_note, curr_octave, num)
                curr_note = next_note
            pattern.append(curr_segment)
        self.patterns[pattern_name] = pattern

    def print_patterns(self):
        for name, pattern in self.patterns.items():
            print(f'{name}:')
            for segment in pattern:
                print(*segment)

    def generate_new_octave(self, start_note, next_note, curr_octave, step_size):
        """
        Updates the current octave given the following.
        There are two situations in which the octave will change:
        1) if the note goes above or equal to the next higher C, or if the note goes below the next lower C,
        2) if the step size is greater than an octave
        The first scenario will cause the indices to "wrap around", since the notes list is from C to B, meaning if the
        octave is jumped, the indices will appear in backwards order. These two cases are accounted for in the
        conditionals.
        The second is dealt with by using floor division on the step_size compared to the number of notes in the scale
        and using that as a shift value.
        :param start_note: note from self.notes
        :param next_note: note from self.notes
        :param curr_octave: int representing scientific pitch octave
        :param step_size: curr step size in the scale (not chromatic)
        :return: updated octave
        """
        start_index, end_index = notes.index(start_note), notes.index(next_note)
        if step_size > 0 and end_index < start_index:
            curr_octave += 1
        elif step_size < 0 and end_index > start_index:
            curr_octave -= 1

        # Accounts for leaps greater than an octave
        # Must consider sign after the division because, for example, -5//4 = -2 when the shift should be -1.
        shift = sign(step_size) * (abs(step_size) // len(self.notes))
        curr_octave += shift

        return curr_octave


if __name__ == '__main__':
    # scale_object = Scale('C', 'chromatic')
    # scale_object.create_pattern('devlin', [4, 4, 3, -4, -1, -1, 2, -3])
    # scale_object.print_patterns()
    obj = Scale('C', 'minor pentatonic')
    obj.create_pattern('p1', [1, 1, 1, -2])
    obj.print_patterns()
